# mdit — Product Requirements Document

**Version:** 0.1  
**Datum:** 2026-02-24  
**Status:** Draft

---

## 1. Projektziel

`mdit` ist ein nativer macOS-Markdown-Editor mit echtem In-Space-Rendering (Typora-Stil): Markdown-Syntax verschwindet sobald der Cursor eine Formatierungseinheit verlässt — kein Split-View, keine Preview-Pane. Das Dokument selbst ist die Oberfläche.

**Kernversprechen:** Hübsch. Schnell. Nichts Überflüssiges.

---

## 2. Design-Philosophie

- **YAGNI** — Jedes Feature muss seinen Platz rechtfertigen.
- **Lean first** — Keine Einstellungen, die der Nutzer nie anfasst.
- **Native first** — macOS-Konventionen werden respektiert, nicht umgangen.
- **Text first** — Die Schreibfläche ist das UI. Alles andere tritt in den Hintergrund.

---

## 3. Zielnutzer & Scope

**Phase 1:** Ausschließlich für den Entwickler selbst. Kein Onboarding, keine Dokumentation, kein App-Store-Polishing nötig.  
**Phase 2 (optional, later):** Open-Source-Release — erst wenn Phase 1 überzeugt.

---

## 4. Architektur-Entscheidungen

| Entscheidung | Wahl | Begründung |
|---|---|---|
| UI-Paradigma | Native macOS (AppKit) | Kein Overhead, echtes macOS-Feeling |
| Text-Engine | `NSTextView` + Custom `NSTextStorage` / `NSLayoutManager` | Ermöglicht Inline-Rendering auf Attribut-Ebene |
| Document-Model | `NSDocument` (Cocoa Document Architecture) | Autosave + Versionshistorie gratis |
| Sprache | Rust | Performance, Safety, Kernüberzeugung des Projekts |
| AppKit-Binding | `objc2` + `objc2-app-kit` Crates | Aktuellste, gut gewartete Rust-Bindings für AppKit |

---

## 5. Feature-Spezifikation

### 5.1 In-Space Rendering (Kern-Feature)

- Der Editor arbeitet auf einer `NSAttributedString`-Schicht mit eigenem Markdown-AST im Hintergrund.
- Rendering-Regeln:
  - **Cursor außerhalb einer Span:** Syntax-Zeichen (`**`, `_`, `~~`, `` ` ``, `#` etc.) werden ausgeblendet (Character-Attribute `NSForegroundColorAttributeName` = transparent oder Schriftgröße 0), Formatierung wird als visuelle Attribute angezeigt.
  - **Cursor innerhalb einer Span:** Syntax-Zeichen werden sichtbar (Source-Modus für die aktuelle Zeile/Block).
  - Granularität: **zeilenweise** für Block-Elemente (Headings, Code-Blöcke, Listen), **span-weise** für Inline-Elemente (Bold, Italic, Links).
- Inkrementelles Parsing bei jeder Änderung (nur betroffener Paragraph wird neu geparst).

### 5.2 Unterstützte Markdown-Elemente

**Inline:**
- Bold (`**text**`), Italic (`*text*` / `_text_`), Bold+Italic
- Inline Code (`` `code` ``)
- Links (`[label](url)`) — URL wird im Rendered-State ausgeblendet, Label bleibt
- Strikethrough (`~~text~~`)
- Footnote-Referenzen (`[^1]`)

**Block:**
- Headings H1–H6
- Unordered + Ordered Lists (inkl. Nested)
- Blockquotes (`>`)
- Fenced Code-Blöcke (` ``` lang `) mit Syntax-Highlighting
- Tables (GFM-Stil)
- Footnote-Definitionen
- Horizontale Regel (`---`)

**Erweiterungen:**
- **Math / LaTeX:** Inline (`$...$`) und Block (`$$...$$`) — gerendert via eingebettetes `WKWebView`-Overlay mit KaTeX (nur für Math-Blöcke, nicht für den gesamten Editor)
- **Syntax-Highlighting in Code-Blöcken:** via `syntect` Crate (pure Rust, TextMate-Grammatiken)

### 5.3 Datei-Operationen

- Öffnen: einzelne `.md`-Dateien (Finder, Drag & Drop, `File > Open`, Recent Files)
- Speichern: `NSDocument`-Autosave (kontinuierlich) + manuell Cmd+S
- Versionshistorie: macOS-eigenes „Browse All Versions" (`File > Revert To`)
- Kein Vault, kein Folder-Management — pure Einzeldatei-Semantik
- Unterstützte Encoding: UTF-8 (ausschließlich)

### 5.4 Bild-Handling

- Bilder werden inline gerendert (skaliert auf Editorbreite, max. Originalgröße)
- **Paste-to-Embed:** Bild aus Clipboard (oder Drag & Drop) einfügen →
  1. Automatisch gespeichert in `<dateiname>-assets/<uuid>.<ext>` neben der `.md`-Datei
  2. Relativer Markdown-Link wird eingefügt: `![](dateiname-assets/uuid.png)`
- Unterstützte Formate: PNG, JPEG, GIF, WebP, SVG

### 5.5 UI-Chrome

```
┌─────────────────────────────────────────────┐
│  [Fensterrahmen / Titlebar — Dateiname]      │
│─────────────────────────────────────────────│
│                                              │
│   [zentrierte Textfläche, max. ~700px]       │
│                                              │
│                                              │
└─────────────────────────────────────────────┘
```

- **Keine Toolbar**, keine Sidebar, kein Statusbar
- **Zentrierte, breiten-limitierte Schreibfläche** (~700px max, responsive Margins)
- **Floating Formatting Toolbar:** erscheint kontextuell bei Textauswahl, verschwindet sonst
  - Buttons: Bold · Italic · Code · Strikethrough · Link · H1/H2/H3 (Dropdown)
  - Position: direkt über der Selektion, leicht transparent mit Blur-Hintergrund (NSVisualEffectView)
- **Focus-Mode (optional, Phase 1.x):** Vollbild + Absatz-Highlighting

### 5.6 Typografie

- **Font:** SF Pro Text (Body), SF Pro Display (Headings), SF Mono (Code-Blöcke, Inline-Code)
- **Schriftgröße:** 16pt Body (nicht konfigurierbar in Phase 1)
- **Zeilenabstand:** 1.6× für angenehmes Lesen
- **Heading-Größen:** H1 2.0em, H2 1.6em, H3 1.3em, H4–H6 1.0em (Bold)

### 5.7 Themes / Appearance

- **Light Mode** und **Dark Mode** — folgt macOS-System-Setting automatisch
- Manueller Toggle: `View > Appearance > Light / Dark / System` (Menüpunkt)
- Farbpalette: bewusst dezent, kein Syntax-Rainbow. Nur strukturelle Hinweis-Farben (z.B. Heading-Akzentfarbe, Link-Farbe, Code-Hintergrund).

### 5.8 PDF-Export

- `File > Export as PDF…` → Standard macOS Print-Dialog mit PDF-Speicheroption
- Rendering basiert auf dem aktuellen Dokument-Zustand (alle Syntax ausgeblendet, formatiert)
- Keine Custom-PDF-Pipeline in Phase 1 — macOS `NSPrintOperation` genügt

### 5.9 Keyboard Shortcuts

| Aktion | Shortcut |
|---|---|
| Bold | Cmd+B |
| Italic | Cmd+I |
| Inline Code | Cmd+E |
| Link einfügen | Cmd+K |
| Heading H1–H3 | Cmd+1 / 2 / 3 |
| Neues Dokument | Cmd+N |
| Öffnen | Cmd+O |
| Speichern | Cmd+S |
| PDF Export | Cmd+Shift+E |
| Versionshistorie | Cmd+Opt+S (via Menü) |
| Appearance Toggle | Cmd+Shift+L |

---

## 6. Non-Goals (explizit außerhalb Scope)

- Kein Vault / Folder-Management (kein Obsidian-Modus)
- Keine Plugins / Extension-API
- Kein Sync (iCloud-Sync über Standard-NSDocument ist OK, aber kein Custom-Sync)
- Kein iOS / iPadOS-Port in Phase 1
- Keine Kollaborations-Features
- Kein Dark-Theme-Editor für den Source-Code (kein „Raw Markdown"-Modus)
- Keine Custom-Fonts oder Font-Einstellungen in Phase 1
- Kein Spell-Check (macOS-eigene NSTextView-Rechtschreibprüfung ist OK, aber kein eigenes System)

---

## 7. Technischer Stack

| Komponente | Crate / Technologie |
|---|---|
| AppKit-Bindings | `objc2` + `objc2-app-kit` |
| Markdown-Parser | `comrak` (CommonMark + GFM-Extensions) |
| Syntax-Highlighting | `syntect` |
| Math-Rendering | `WKWebView` + KaTeX (embedded HTML, nur für Math-Blöcke) |
| Build | Cargo |
| Mindest-macOS | 13.0 (Ventura) |

---

## 8. Kern-Herausforderungen

1. **Custom NSTextStorage:** Das Herz des Projekts. Muss Markdown-AST und `NSAttributedString` synchron halten, inkrementell parsen und Cursor-Position tracked. Größtes technisches Risiko.

2. **Math-Rendering:** Ein `WKWebView` pro Math-Block ist aufwändig. Alternative: SVG via `mathml`-Rendering direkt in NSAttributedString — zu evaluieren.

3. **Typora-Effekt bei Tabellen:** Tabellen als `NSTextAttachment` oder als custom `NSTextBlock` — beide Ansätze komplex, zu prüfen welcher sich sauberer integriert.

4. **Rust ↔ AppKit:** `objc2`-Bindings sind mächtig aber low-level. Jede AppKit-Klasse die wir subclassen (NSTextStorage, NSLayoutManager) erfordert sorgfältige Rust-ObjC-Brücke.

---

## 9. Erfolgs-Kriterien (Phase 1)

- [ ] Datei öffnen, bearbeiten, autosaven funktioniert zuverlässig
- [ ] In-Space-Rendering für alle Inline-Elemente funktioniert ohne sichtbare Artefakte
- [ ] Code-Blöcke mit Syntax-Highlighting werden korrekt gerendert
- [ ] Tables, Footnotes werden korrekt gerendert
- [ ] Math-Blöcke (LaTeX) werden korrekt gerendert
- [ ] Bilder werden inline gerendert, Paste-to-Embed funktioniert
- [ ] Light/Dark-Mode-Toggle funktioniert
- [ ] PDF-Export produziert saubere Ausgabe
- [ ] App startet in unter 200ms
- [ ] Keine spürbaren Lag-Artefakte beim Tippen (< 16ms Input-Latenz)
